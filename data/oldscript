function RunRemoteProcess{
	param($VirtualMachine, $Credentials, $Exe, $Arguments, $Sleep)

	$vm = New-Object VMware.Vim.ManagedObjectReference
	$vm.type = "VirtualMachine"
	$vm.Value = $VirtualMachine.Id.Split('-')[1]

	$_this = Get-View -Id "GuestProcessManager-ha-guest-operations-process-manager"

	$spec = New-Object VMware.Vim.GuestProgramSpec
	$spec.ProgramPath = $Exe
	$spec.arguments = $Arguments

	$processId = $_this.StartProgramInGuest($vm, $Credentials, $spec)
	$processInfo = $null
	do
	{
		$processInfo = $_this.ListProcessesInGuest($vm, $Credentials, $processId)
		Start-Sleep -Seconds $Sleep
	}
	while($processInfo[0].exitCode -eq $null -and $processInfo.Count -eq 1)

	if($processInfo[0].exitCode -ne 0)
	{
		exit 1
	}
}

function CopyFileToGuest{
	param($VirtualMachine, $Credentials, $LocalFilePath, $RemoteFilePath)
	$_fileMgr = Get-View -Id "GuestFileManager-ha-guest-operations-file-manager"

	$vm = New-Object VMware.Vim.ManagedObjectReference
	$vm.type = "VirtualMachine"
	$vm.Value = $VirtualMachine.Id.Split('-')[1]

	$fileAttributes = New-Object VMware.Vim.GuestFileAttributes
	$file = Get-Item $LocalFilePath
	$fileSize = $file.length
	$url = $_fileMgr.InitiateFileTransferToGuest($vm, $Credentials, $RemoteFilePath, $fileAttributes, $fileSize, $true)
	$url = $url.Replace("*", $ESXiHost);
	$_this = Get-View -Id "GuestProcessManager-ha-guest-operations-process-manager"
	$content = [System.IO.File]::ReadAllBytes($LocalFilePath)

	[Net.HttpWebRequest] $request = [Net.HttpWebRequest]::Create($url)
	$request.method = "PUT"
	$request.ContentLength = $content.Length
	$reqStream = $request.GetRequestStream()
	$reqStream.Write($content, 0, $content.Length)
	$reqStream.Close()
	[Net.HttpWebResponse] $response = $request.getResponse()
	if($response.StatusCode -ne 200)
	{
		exit 1
	}
}

function LoadSnapin{
  param($PSSnapinName)
  if (!(Get-PSSnapin | where {$_.Name   -eq $PSSnapinName})){
    Add-pssnapin -name $PSSnapinName
  }
}
LoadSnapin -PSSnapinName   "VMware.VimAutomation.Core"

function Get-ScriptDirectory
{
$Invocation = (Get-Variable MyInvocation -Scope 1).Value
Split-Path $Invocation.MyCommand.Path
}

function ProcessContentToSections($content)
{
	$allMatches = [regex]::Matches($content, "---UHURUMON-\w*")
	$splits = [regex]::Split($content, "---UHURUMON-\w*")

	$i = 0
	$result = @{}
	foreach ($match in $allMatches)
	{
		$sectionName = $match.value.replace("---UHURUMON-", "")
		$sessionContent = $splits[$i + 1]
		$result.set_item($sectionName, $sessionContent.trim())
		$i++
	}

	return $result
}

function AddWindowsColumns($sections)
{
	$hash = @{}
	$cpu = [regex]::Match($sections.get_item("CPU_TIME"), '"\d*/\d*/\d*.*",".*"').Value.Split(",", [StringSplitOptions]::RemoveEmptyEntries)[1].Replace('"', "")
	$totalPhysicalRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Total Physical Memory:\s*\S*").Value.Split(":", [StringSplitOptions]::RemoveEmptyEntries)[1].Replace(',', "").Trim()
	$freePhysicalRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Available Physical Memory:\s*\S*").Value.Split(":", [StringSplitOptions]::RemoveEmptyEntries)[1].Replace(',', "").Trim()

	$totalSwapRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Virtual Memory: Max Size:\s*\S*").Value.Split(":", [StringSplitOptions]::RemoveEmptyEntries)[2].Replace(',', "").Trim()
	$freeSwapRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Virtual Memory: Available:\s*\S*").Value.Split(":", [StringSplitOptions]::RemoveEmptyEntries)[2].Replace(',', "").Trim()

	$systemDiskTotal = [regex]::Match($sections.get_item("DISKUSAGEC"), "Total # of bytes\s*:\s*\d*").Value.Split(':', [StringSplitOptions]::RemoveEmptyEntries)[1].Trim()
	$systemDiskFree = [regex]::Match($sections.get_item("DISKUSAGEC"), "Total # of avail free bytes\s*:\s*\d*").Value.Split(':', [StringSplitOptions]::RemoveEmptyEntries)[1].Trim()

	$component = $sections.get_item("COMPONENT_INFO").Trim()


	$hash.set_item("CPU Usage", $cpu)
	$hash.set_item("Total Physical RAM", $totalPhysicalRAM)
	$hash.set_item("Free Physical RAM", $freePhysicalRAM)
	$hash.set_item("Total Swap RAM", $totalSwapRAM)
	$hash.set_item("Free Swap RAM", $freeSwapRAM)
	$hash.set_item("System Disk Total", $systemDiskTotal)
	$hash.set_item("System Disk Free", $systemDiskFree)
	$hash.set_item("Component", $component)

	return $hash
}

function AddLinuxColumns($sections)
{
	$hash = @{}

	$cpu = [regex]::Match($sections.get_item("CPU_TIME"), ":.*us").Value.Replace(":", "").Replace("%us", "").Trim()
	$totalPhysicalRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Mem:\s*\d*").Value.Replace("Mem:", "").Trim()
	$freePhysicalRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Mem:\s*\d*\s*\d*\s*\d*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[3]
	$cachedPhysicalRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Mem:\s*\d*\s*\d*\s*\d*\s*\d*\s*\d*\s*\d*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[6]

	$totalSwapRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Swap:\s*\d*").Value.Replace("Swap:", "").Trim()
	$freeSwapRAM = [regex]::Match($sections.get_item("SYSTEM_INFO"), "Swap:\s*\d*\s*\d*\s*\d*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[3]

	if ([regex]::IsMatch($sections.get_item("DISK_USAGE"), "\/dev\/sda1\s*\S*"))
	{
		$systemDiskTotal = [regex]::Match($sections.get_item("DISK_USAGE"), "\/dev\/sda1\s*\S*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$systemDiskFree = [regex]::Match($sections.get_item("DISK_USAGE"), "\/dev\/sda1\s*\S*\s*\S*\s*\S*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[3]
	}

	if ([regex]::IsMatch($sections.get_item("DISK_USAGE"), "\/dev\/sdb2\s*\S*"))
	{
		$ephemeralDiskTotal = [regex]::Match($sections.get_item("DISK_USAGE"), "\/dev\/sdb2\s*\S*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$ephemeralDiskFree = [regex]::Match($sections.get_item("DISK_USAGE"), "\/dev\/sdb2\s*\S*\s*\S*\s*\S*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[3]
	}

	if ([regex]::IsMatch($sections.get_item("DISK_USAGE"), "\/dev\/sdc1\s*\S*"))
	{
		$persistentDiskTotal = [regex]::Match($sections.get_item("DISK_USAGE"), "\/dev\/sdc1\s*\S*\s*\S*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$persistentDiskFree = [regex]::Match($sections.get_item("DISK_USAGE"), "\/dev\/sdc1\s*\S*\s*\S*\s*\S*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[3]
	}

	$component = $sections.get_item("COMPONENT_INFO").Trim()

	$hash.set_item("CPU Usage", $cpu)
	$hash.set_item("Total Physical RAM", $totalPhysicalRAM)
	$hash.set_item("Free Physical RAM", $freePhysicalRAM)
	$hash.set_item("Cached Physical RAM", $cachedPhysicalRAM)
	$hash.set_item("Total Swap RAM", $totalSwapRAM)
	$hash.set_item("Free Swap RAM", $freeSwapRAM)
	$hash.set_item("System Disk Total", $systemDiskTotal)
	$hash.set_item("System Disk Free", $systemDiskFree)
	$hash.set_item("Ephemeral Disk Total", $ephemeralDiskTotal)
	$hash.set_item("Ephemeral Disk Free", $ephemeralDiskFree)
	$hash.set_item("Persistent Disk Total", $persistentDiskTotal)
	$hash.set_item("Persistent Disk Free", $persistentDiskFree)
	$hash.set_item("Component", $component)

	return $hash
}

function ProcessSectionsToData($sections)
{
	$result = @{}
	$component = $sections.get_item("COMPONENT_INFO")


	if ($component -eq "Linux DEA")
	{
		$result = AddLinuxColumns($sections)

		$dropletCount = [regex]::Matches($sections.get_item("DROPLETCOUNTFOLDER"), "vcap-user").Count
		$totalWorkerProcesses = [regex]::Matches($sections.get_item("WORKERPROCESSESIISCOUNT"), "\/var\/vcap\/data\/dea\/apps").Count

		$totalWorkerMemory = 0
		$allWorkers = [regex]::Matches($sections.get_item("WORKERPROCESSESMEMORY"), "\d*\s*\d*\s*\?[^\r]*/var/vcap/data/dea/apps")
		foreach ($match in $allWorkers)
		{
			$workerMemory = $match.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
			$totalWorkerMemory += $workerMemory
		}

		$deaProcessMemory = [regex]::Match($sections.get_item("DEAPROCESSMEMORY"), "\d*\s*\d*\s*\?[^\r]*dea.yml").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
		$deaProvisionableMemory = [regex]::Match($sections.get_item("CONFIG"), "max_memory:\s*\d*").Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]

		$dropletMemoryMatches = [regex]::Matches($sections.get_item("DROPLETDATA"), '"mem_quota":\s*\d*')
		$deaProvisionedMemory = 0

		foreach ($match in $dropletMemoryMatches)
		{
			$dropletMemory = $match.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
			$deaProvisionedMemory += $dropletMemory
		}

		$deaDropletCount = [regex]::Matches($sections.get_item("DROPLETDATA"), '"droplet_id"').Count

		$result.set_item("Droplet Count On Disk", $dropletCount)
		$result.set_item("Total Worker Processes Count", $totalWorkerProcesses)
		$result.set_item("Total Worker Process Used Memory", $totalWorkerMemory)
		$result.set_item("DEA Service Used Memory", $deaProcessMemory)
		$result.set_item("DEA Provisionable Memory", $deaProvisionableMemory)
		$result.set_item("DEA Provisioned Memory", $deaProvisionedMemory)
		$result.set_item("DEA Droplet Count", $deaDropletCount)
	}
	if ($component -eq "Stager")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "MySQL Node")
	{
		$result = AddLinuxColumns($sections)
		$serviceCountDisk = [regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*d\w{32}').Count
		$maxServicesOnNode = [regex]::Match($sections.get_item("CONFIG"), 'capacity:\s*\d*').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$serviceSizesOnDisk = ([regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*\d*-\d*-\d*\s*\d\d:\d\d\s*d\w{32}') | Select-Object @{"name" = "Value"; "Expression" = {$_.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]}}  | Measure-Object -Sum value ).Sum
		$serverMemory = [regex]::Match($sections.get_item("SERVERMEMORY"), 'vcap[^\r]*\?').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[4]
		$nodeMemory = [regex]::Match($sections.get_item("NODEPROCESSMEMORY"), '\d*\s*\d*\s*\?[^\r]*ruby').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
		$serviceCount = [regex]::Matches($sections.get_item("SERVICEDB"), 'd\w{32}').Count

		$result.set_item("Service Count On Disk", $serviceCountDisk)
		$result.set_item("Maximum Provisionable Services", $maxServicesOnNode)
		$result.set_item("Total Service Size On Disk", $serviceSizesOnDisk)
		$result.set_item("MySQL Service Memory", $serverMemory)
		$result.set_item("MySQL Node Service Memory", $nodeMemory)
		$result.set_item("Provisioned Services", $serviceCount)
	}
	if ($component -eq "PostgreSQL Node")
	{
		$result = AddLinuxColumns($sections)
		$serviceCountDisk = [regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d{2}\r').Count
		$maxServicesOnNode = [regex]::Match($sections.get_item("CONFIG"), 'capacity:\s*\d*').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$serviceSizesOnDisk = ([regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*\d{4}-\d{2}-\d{2}\s*\d{2}:\d{2}\s*\d{2}') | Select-Object @{"name" = "Value"; "Expression" = {$_.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]}}  | Measure-Object -Sum value ).Sum
		$serverMemory = [regex]::Match($sections.get_item("SERVERMEMORY"), 'vcap[^\r]*\?').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[4]
		$nodeMemory = [regex]::Match($sections.get_item("NODEPROCESSMEMORY"), '\d*\s*\d*\s*\?[^\r]*ruby').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
		$serviceCount = [regex]::Matches($sections.get_item("SERVICEDB"), 'd\w{32}').Count

		$result.set_item("Service Count On Disk", $serviceCountDisk)
		$result.set_item("Maximum Provisionable Services", $maxServicesOnNode)
		$result.set_item("Total Service Size On Disk", $serviceSizesOnDisk)
		$result.set_item("PostgreSQL Service Memory", $serverMemory)
		$result.set_item("PostgreSQL Node Service Memory", $nodeMemory)
		$result.set_item("Provisioned Services", $serviceCount)
	}
	if ($component -eq "MongoDB Node")
	{
		$result = AddLinuxColumns($sections)
		$serviceCountDisk = [regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*d\w{32}').Count
		$maxServicesOnNode = [regex]::Match($sections.get_item("CONFIG"), 'capacity:\s*\d*').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$serviceSizesOnDisk = ([regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*\d*-\d*-\d*\s*\d\d:\d\d\s*d\w{32}') | Select-Object @{"name" = "Value"; "Expression" = {$_.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]}}  | Measure-Object -Sum value ).Sum
		$serverMemory = [regex]::Match($sections.get_item("SERVERMEMORY"), 'vcap[^\r]*\?').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[4]
		$nodeMemory = [regex]::Match($sections.get_item("NODEPROCESSMEMORY"), '\d*\s*\d*\s*\?[^\r]*ruby').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
		$serviceCount = [regex]::Matches($sections.get_item("SERVICEDB"), 'd\w{32}').Count

		$result.set_item("Service Count On Disk", $serviceCountDisk)
		$result.set_item("Maximum Provisionable Services", $maxServicesOnNode)
		$result.set_item("Total Service Size On Disk", $serviceSizesOnDisk)
		$result.set_item("MongoDB Service Memory", $serverMemory)
		$result.set_item("MongoDB Node Service Memory", $nodeMemory)
		$result.set_item("Provisioned Services", $serviceCount)
	}
	if ($component -eq "Redis Node")
	{
		$result = AddLinuxColumns($sections)
		$serviceCountDisk = [regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*d\w{32}').Count
		$maxServicesOnNode = [regex]::Match($sections.get_item("CONFIG"), 'capacity:\s*\d*').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$serviceSizesOnDisk = ([regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*\d*-\d*-\d*\s*\d\d:\d\d\s*d\w{32}') | Select-Object @{"name" = "Value"; "Expression" = {$_.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]}}  | Measure-Object -Sum value ).Sum
		$serverMemory = [regex]::Match($sections.get_item("SERVERMEMORY"), 'vcap[^\r]*\?').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[4]
		$nodeMemory = [regex]::Match($sections.get_item("NODEPROCESSMEMORY"), '\d*\s*\d*\s*\?[^\r]*ruby').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
		$serviceCount = [regex]::Matches($sections.get_item("SERVICEDB"), 'd\w{32}').Count

		$result.set_item("Service Count On Disk", $serviceCountDisk)
		$result.set_item("Maximum Provisionable Services", $maxServicesOnNode)
		$result.set_item("Total Service Size On Disk", $serviceSizesOnDisk)
		$result.set_item("Redis Service Memory", $serverMemory)
		$result.set_item("Redis Node Service Memory", $nodeMemory)
		$result.set_item("Provisioned Services", $serviceCount)
	}
	if ($component -eq "RabbitMQ Node")
	{
		$result = AddLinuxColumns($sections)
		$serviceCountDisk = [regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*d\w{32}').Count
		$maxServicesOnNode = [regex]::Match($sections.get_item("CONFIG"), 'capacity:\s*\d*').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[1]
		$serviceSizesOnDisk = ([regex]::Matches($sections.get_item("DATABASESONDRIVE"), '\d*\s*\d*-\d*-\d*\s*\d\d:\d\d\s*d\w{32}') | Select-Object @{"name" = "Value"; "Expression" = {$_.Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]}}  | Measure-Object -Sum value ).Sum
		$serverMemory = [regex]::Match($sections.get_item("SERVERMEMORY"), 'vcap[^\r]*\?').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[4]
		$nodeMemory = [regex]::Match($sections.get_item("NODEPROCESSMEMORY"), '\d*\s*\d*\s*\?[^\r]*ruby').Value.Split(' ', [StringSplitOptions]::RemoveEmptyEntries)[0]
		$serviceCount = [regex]::Matches($sections.get_item("SERVICEDB"), 'd\w{32}').Count

		$result.set_item("Service Count On Disk", $serviceCountDisk)
		$result.set_item("Maximum Provisionable Services", $maxServicesOnNode)
		$result.set_item("Total Service Size On Disk", $serviceSizesOnDisk)
		$result.set_item("RabbitMQ Service Memory", $serverMemory)
		$result.set_item("RabbitMQ Node Service Memory", $nodeMemory)
		$result.set_item("Provisioned Services", $serviceCount)
	}
	if ($component -eq "Cloud Controller")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Cloud Controller Database")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Collector")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Dashboard")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Network File System")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Open TSTB")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "NATS Server")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Router")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Syslog Aggregator")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "VCAP Redis")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "MySQL Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "PostgreSQL Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "MongoDB Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Redis Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "RabbitMQ Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "SqlServer Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "UhuruFS Gateway")
	{
		$result = AddLinuxColumns($sections)
	}
	if ($component -eq "Windows DEA")
	{
		$result = AddWindowsColumns($sections)
	}
	if ($component -eq "MS SQL Node")
	{
		$result = AddWindowsColumns($sections)
	}
	if ($component -eq "Uhuru API")
	{
		$result = AddWindowsColumns($sections)
	}
	if ($component -eq "Data Analysis Box")
	{
		$result = AddWindowsColumns($sections)
	}
	if ($component -eq "Uhuru File System")
	{
		$result = AddWindowsColumns($sections)
	}

	return $result
}


$ESXiHost = "199.16.206.70"
$user = "administrator"
$password = "Trump3t"

echo "Trying to connect to ESX host"

connect-viserver $ESXiHost -User $user -Password $password

# get windows VMs
$windowsVMs = @{
	"192.168.5.11" = @{"name" = "WinUC5011" };
	"192.168.5.4" = @{"name" = "WinUC5004" };
	"192.168.5.6" = @{"name" = "WinUC5006" };
	"192.168.5.12" = @{"name" = "WinUC5012" };
	"192.168.5.3" = @{"name" = "WinUC5003" };
	"192.168.5.5" = @{"name" = "WinUC5005" };
	"192.168.5.9" = @{"name" = "WinUC5009" };
	"199.16.206.80" = @{"name" = "WinUC5001" };
	"192.168.1.127" = @{"name" = "WinUC1127" };
	"192.168.6.1" = @{"name" = "WinUC6001" };
	"192.168.6.2" = @{"name" = "WinUC6002" };
	"192.168.5.10" = @{"name" = "WinUC5010" };
	"192.168.5.13" = @{"name" = "WinUC5013" };
	"192.168.6.3" = @{"name" = "WinUC6003" };
	"192.168.5.8" = @{"name" = "WinUC5008" };
	"192.168.1.129" = @{"name" = "WinUC1129" };
	"192.168.5.53" = @{"name" = "WinUC5053" };
	"192.168.5.52" = @{"name" = "WinUC5052" };
	"192.168.5.51" = @{"name" = "WinUC5051" }
}

$allESXVMs = Get-VM

foreach ($ip in $($windowsVMs.keys))
{
	$winentry = $windowsVMs.get_item($ip)
	$winentry.set_item("vm", ($allESXVMs | where { $_.Guest.IPAddress -contains $ip }) )
	$winentry.set_item("pool", "win" )
}

$boshVMsOutput = C:\cygwin\bin\bash.exe --login -i -c "bosh vms --full"

$allVMs = $windowsVMs

$boshVMs = $boshVMsOutput | where {$_ -match "\|.*\|.*\|.*\|.*\..*\..*\..*\|.*\|" }

foreach ($line in $boshVMs)
{
	if ($line -ne $null)
	{
		$columns = $line.split("|")
		$name = $columns[1].trim()
		$pool = $columns[3].trim()
		$ip = $columns[4].trim()
		$cid = $columns[5].trim()
		$vm = $allESXVMs | where { $_.name -eq $cid }
		$allVMs.Add($ip, @{"pool" = $pool; "name" = $name; "vm" = $vm})
	}
}


$detailedVMs = @{}


C:\cygwin\bin\bash.exe --login -i -c "rm -rf ~/.ssh/known_hosts"

foreach($ip in $($allVMs.keys))
{
    $vm = $allVMs.get_item($ip).get_item("vm")
	$pool = $allVMs.get_item($ip).get_item("pool")
	if (($vm.Guest.OSFullName -like "*Linux*") -or ($pool -ne "win"))
	{
		#echo "/cygdrive/d/Backups/Tools/runssh.sh root $password $ip /cygdrive/d/Backups/Tools/getlinuxinfo.sh $pool"
		C:\cygwin\bin\bash.exe --login -i -c "/cygdrive/d/Backups/Tools/runssh.sh root $ip /cygdrive/d/Backups/Tools/getlinuxinfo.sh" > d:\Backups\InfrastructureMonitoring\$ip.txt
	}

	if ($vm.Guest.OSFullName -like "*Windows*")
	{
		d:\Backups\Tools\PsExec.exe \\$ip -u administrator -p Trump3t -c d:\Backups\Tools\getwininfo.bat > d:\Backups\InfrastructureMonitoring\$ip.txt
	}
}

$path = "d:\Backups\InfrastructureXml.xml"
$doc = [xml] "<boxes />"
$boxes = $doc.DocumentElement

# process each file
foreach($ip in $($allVMs.keys))
{
	$file = Get-Content "d:\Backups\InfrastructureMonitoring\$ip.txt"
	$sections = ProcessContentToSections($file)
	$table = ProcessSectionsToData($sections)

	$box = $doc.CreateElement("box")

	foreach($key in $($table.keys))
	{
		$info = $doc.CreateElement("info")

		$info.SetAttribute("name", $key)
		$info.SetAttribute("value", $table.get_item($key))

		$box.AppendChild($info)
	}

	$info = $doc.CreateElement("info")
	$info.SetAttribute("name", "IP Address")
	$info.SetAttribute("value", $ip)
	$box.AppendChild($info)

	$info = $doc.CreateElement("info")
	$info.SetAttribute("name", "Machine")
	$info.SetAttribute("value", $allVMs.get_item($ip).get_item("name"))
	$box.AppendChild($info)

	$boxes.AppendChild($box)
}

$doc.Save($path)


